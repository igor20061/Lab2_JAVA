# Лягинсков Игорь Группа ИТ-5 Лабораторная №2

# Задание 1: Класс Point для работы с точками на плоскости
## Задача 1: Создание класса Point
### Текст задачи
Точка	координат.		
Создайте	сущность	Точка,	расположенную	на	двумерной	плоскости,	которая	описывается:	
• Координата	Х:	число	
• Координата	Y:	число	
• Может	возвращать	текстовое	представление	вида	“{X;Y}”	
Необходимо	создать	три	точки	с	разными	координатами	и	вывести	на	экран	их	текстовое	
представление. 

### Алгоритм решения
1. Создание структуры класса:
   - Объявить класс Point с полями x и y типа double для хранения координат
   - Поля сделаны публичными для простоты доступа в учебных целях

2. Конструктор:
   - Реализовать конструктор `Point(double x, double y)`, который инициализирует координаты точки
   - Конструктор принимает оба параметра типа double, но допускает передачу целых чисел благодаря автоматическому приведению типов

3. Метод получения координат:
   - Создать метод `Coordinates()`, который возвращает строковое представление координат в формате "{x;y}"
   - Метод использует конкатенацию строк для формирования результата

4. Демонстрация работы:
   - В методе main создать несколько экземпляров класса Point с разными координатами
   - Показать работу метода Coordinates() для каждой точки
   - Продемонстрировать обработку целых и дробных чисел


## Задача 3: Создание класса Name
### Текст задачи
Создайте	сущность	Имя,	которая	описывается	тремя	параметрами:	Фамилия,	Личное	имя,	
Отчество.	Имя	может	быть	приведено	к	строковому	виду,	включающему	традиционное	
представление	всех	трех	параметров:	Фамилия	Имя	Отчество	(например	“Иванов	Иван	
Иванович”).	Необходимо	предусмотреть	возможность	того,	что	какой-либо	из	параметров	может	
быть	не	задан,	и	в	этом	случае	он	не	учитывается	при	приведении	к	текстовому	виду.	
Необходимо	создать	следующие	имена:	
• Клеопатра	
• Пушкин	Александр	Сергеевич	
• Маяковский	Владимир	
Обратите	внимание,	что	при	выводе	на	экран,	не	заданные	параметры	никак	не	участвуют	в	
образовании	строки.	


### Алгоритм решения
1. Структура класса:
   - Приватные поля: `Surname` (фамилия), `Name` (личное имя), `MiddleName` (отчество)
   - Все поля типа String, могут содержать null значения

2. Конструкторы:
   - Полный конструктор: `Name(String Surname, String Name, String MiddleName)` - принимает все три компонента
   - Конструктор без отчества: `Name(String Surname, String Name)` - устанавливает MiddleName в null
   - Конструктор только с именем: `Name(String Name)` - устанавливает Surname и MiddleName в null
   - Использована цепочка вызовов конструкторов через `this()`

3. Метод формирования полного имени:
   - `getFullName()` собирает полное имя из доступных компонентов
   - Алгоритм сборки:
     - Если фамилия присутствует - добавляет её
     - Если имя присутствует - добавляет с пробелом
     - Если отчество присутствует - добавляет с пробелом
     - Использует StringBuilder для эффективной конкатенации

4. Метод toString():
   - Переопределен для возврата полного имени
   - Позволяет напрямую использовать объект в выводе

# Задание 3: Класс City для моделирования транспортной сети
## Задача 3: Создание класса City с возможностью добавления путей
### Текст задачи
Создайте	сущность	Город,	которая	будет	представлять	собой	точку	на	карте	со	следующими	
характеристиками:	
• Название	города	
• Набор	путей	к	следующим	городам,	где	путь	представляет	собой	сочетание	Города	и	
стоимости	поездки	в	него.	
Кроме	того,	Город	может	возвращать	текстовое	представление,	в	виде	названия	города	и	списка	
связанных	с	ним	городов	(в	виде	пары:	“название:стоимость”).	
Используя	разработанную	сущность	реализуйте	схему,	представленную	на	рисунке	2.	

### Алгоритм решения
1. Структура данных:
   - `name` - название города (String)
   - `connectedCities` - массив связанных городов (City[])
   - `costs` - массив стоимостей проезда (int[])
   - Оба массива инициализируются пустыми при создании города

2. Основной конструктор:
   - `City(String name)` - создает город с указанным именем и пустыми массивами связей

3. Метод добавления пути:
   - `addPath(City city, int cost)` - добавляет связь с другим городом
   - Алгоритм добавления:
     - Создает новые массивы на 1 элемент больше текущих
     - Копирует существующие данные в новые массивы
     - Добавляет новый город и стоимость в конец массивов
     - Заменяет старые массивы новыми

4. Метод toString():
   - Формирует читабельное описание города и его связей
   - Если связей нет - выводит "нет путей"
   - Если связи есть - перечисляет их в формате "город:стоимость"

# Задание 4: Расширение класса City
## Задача 8: Добавление конструктора с предустановленными связями
### Текст задачи
Измените	сущность	Город	из	задачи	3.3.	Новые	требования	включают:	
• Город	можно	создать	указав	только	название	
• Город	можно	создать	указав	название	и	набор	связанных	с	ним	городов	и	стоимостей	
путей	к	ним

### Алгоритм решения
1. Новый конструктор:
   - `City(String name, City[] connectedCities, int[] costs)` - принимает название, массив связанных городов и массив стоимостей
   - Обеспечивает гибкую инициализацию объекта

2. Обработка некорректных данных:
   - Проверка на null для входных массивов
   - Если переданы null-массивы, создает пустые массивы для избежания NullPointerException
   - Если массивы корректны - присваивает их полям объекта

3. Совместимость с существующим кодом:
   - Старый конструктор остается работоспособным
   - Все существующие методы продолжают работать корректно
   - Добавленный функционал не ломает предыдущую реализацию



# Задание 5: Класс Fraction для работы с дробями
## Задача 5: Реализация арифметических операций с дробями
### Текст задачи
Создайте сущность Дробь	со	следующими	особенностями:	
• Имеет	числитель:	целое	число	
• Имеет	знаменатель:	целое	число	
• Дробь	может	быть	создана	с	указанием	числителя	и	знаменателя		
• Может	вернуть	строковое	представление	вида	“числитель/знаменатель”	
• Может	выполнять	операции	сложения,	вычитания,	умножения	и	деления	с	другой	Дробью	
или	целым	числом.	Результатом	операции	должна	быть	новая	Дробь	(таким	образом,обе	
исходные	дроби	не	изменяются)	
Затем	необходимо	выполнить	следующие	задачи:	
1. Создать	несколько	экземпляров	дробей.	
2. Написать	по	одному	примеру	использования	каждого	метода.	
3. Вывести	на	экран	примеры	и	результаты	их	выполнения	в	формате	«1/3	*	2/3	=	2/9»	
4. Посчитать	f1.sum(f2).div(f3).minus(5)
### Алгоритм решения
1. Структура и безопасность:
   - Поля `numerator` и `denominator` объявлены как final для неизменяемости
   - Проверка знаменателя на ноль в конструкторе
   - Два конструктора: с двумя параметрами и с одним (знаменатель = 1)

2. Вспомогательные методы*:
   - `gcd(a, b)` - вычисление НОД с помощью рекурсивного алгоритма Евклида
   - `simplify()` - сокращение дроби с учетом знака
   - Приватные методы для внутренней оптимизации

3. Арифметические операции:
   - Каждая операция возвращает новый объект Fraction
   - **Сложение**: приведение к общему знаменателю
   - **Вычитание**: аналогично сложению
   - **Умножение**: перемножение числителей и знаменателей
   - **Деление**: умножение на обратную дробь с проверкой деления на ноль

4. Перегрузка операций:
   - Для каждой операции реализованы версии для работы с целыми числами
   - Целые числа автоматически преобразуются в дроби со знаменателем 1

5. Цепочки вызовов:
   - Все методы возвращают Fraction, что позволяет строить цепочки
   - Пример: `f1.add(f2).multiply(f3).divide(2)`
